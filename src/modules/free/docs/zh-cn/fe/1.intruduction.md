## 规范

FreeEIS中，任何的功能都应该被实现为独立的模块，而这些独立的模块通常都是可以独立运行的，模块开发人员可以自行开发调试，而不需要依赖于其他部分。而负责集成的人员，只需要将各功能模块关联到一个统一的集成环境中，根据需要对每个功能模块进行配置，即可运行起整套系统。

但FreeEIS也实现了模块对模块的扩展功能，以满足“模块插件”的需求，这种情况下，新开发的“插件”模块需要在被扩展的模块存在的情况下进行。在此种情况下，模块不能真的完全独立开发和运行，但考虑到新模块是某现有模块的扩展插件，此两个模块可以做为一个整体考虑的情况下，我们依然可以说他是独立开发和运行的。

这是FreeEIS开发的第一核心思想。

## 前提条件

FreeEIS前端基于Quasar Framework开发而来，所以你需要对Quasar Framework有一定的了解，而Quasar Framework是一个基于VUE的前端框架，包括组件库和跨平台支持等特性，所以你也需要对VUE有更深的了解。当前版本中，我们使用了Quasar Framework 2.x，其基于VUE3.x。

为了使用FreeEIS开发应用，你还可能需要了解Webpack和NodeJS本身的一些内容。但是因为VUE和Quasar Framework都进一步做了封装，所以在一般情况下，你不需要意识到他们的存在。

## 脚手架

FreeEIS前端开发通过FreeEIS脚手架工程开始。FreeEIS前端脚手架工程基于Quasar Framework的脚手架工程，只是把FreeEIS内核模块嵌入，进而实现了FreeEIS模块的加载和运行工作。

脚手架工程做为模块开发的基础，同时也是系统集成的基础，任何模块的运行都需要通过脚手架工程来完成。

### 运行


```sh
# 安装前端脚手架
$ git clone https://github.com/freeeis/free-fe-starter-kit.git fe

# 安装依赖包
$ cd fe
$ yarn install

# 运行
$ yarn start
```

此时可以通过`http://localhost:8080`来查看系统页面，但请注意终端输出，在当端口8080已经被占用时，可能会使用8081等其他端口。

另需要注意的是，在脚手架中，默认加入了一些内置模块，有些内置模块需要相应后端模块的支持，而由于一些历史原因在这些内置模块开发的时候并没有加入足够的Mock信息，所以单独运行前端脚手架可能会在某些接口调用时报错。我们会逐步添加mock内容以使这些内置模块也可以脱离后端运行。在后面的章节开始介绍实际的开发内容前会有详细的说明如何禁用内置模块，以从一个更加“干净”的环境开始创建自己的模块。

### 目录结构

FreeEIS脚手架目录结构如下：

```
--- app
   -- ...
   -- public
   -- src
      App.vue
      Error404.vue
      -- boot
      -- config
          -- config.default.js
          -- config.development.js
          -- config.production.js
          -- config.test.js
          index.js
      -- css
          app.scss
          quasar.variables.scss
      -- modules
      -- router
      -- stores
      -- utils
      ...
  ...

```

在这个目录结构中，有很多是Quasar Framework所定义的，请参考[官方文档](https://quasar.dev)，我们只介绍在开发FreeEIS应用时直接相关的部分：
- `public`，此目录为静态资源目录，图片图标或其他静态资源放在这里，这个目录中的内容会在编译后直接拷贝到输出目录中。但基于我们的开发规范，我们应该尽力避免使用全局公用的资源，而应该放置在每个模块中，但在某些特殊场景下，我们依然可以这么做。
- `src`，这里是开发代码的存放目录。
  - `App.vue`，这是入口vue文件，通常不需要修改。
  - `Error404.vue`，这是当找不到指定页面报404时，显示的页面。
  - `boot`，这里是Quasar Framework的boot文件存放位置，关于boot文件的详细信息，请参见Quasar Framework。我们在其中加入了必要的文件以支撑FreeEIS的启动。
  - `config`，配置文件存放位置，用于配置FreeEIS中不同运行环境下的全局配置信息，也可以用以覆盖各模块的默认配置以达到定制使用模块的目标。默认我们放入了三个环境的配置文件，development，test和production，但你完全可以根据自己的需要扩充。
    - `config.default.js`，默认配置，所有环境公用的配置信息，或默认的配置信息。会被下面特定运行环境的配置信息覆盖（或扩展）。
    - `config.development.js`，开发环境中的配置信息。
    - `config.production.js`，生产环境中的配置信息。
    - `config.test.js`，测试环境中的配置信息。
    - `index.js`，配置信息入口，此文件会自动加载当前目录中所有配置环境的配置文件，并根据当前运行环境使用相应配置。
  - `css`，全局样式文件保存的位置。我们建议使用FreeEIS的样式皮肤模块，而尽量减少在此处定义全局样式。但基于显而易见的原因，我们保留这里的功能。样式皮肤模块，是一类特殊的模块，专门定义不同的样式皮肤，后续会有详细的介绍。
    - `app.scss`，全局样式入口。
    - `quasar.variables.scss`，全局样式变量定义文件，全局样式变量可以从整体上规范模块样式的设计。
  - `modules`，FreeEIS模块存放目录，模块可以直接保存在此目录中，也可以使用git submodule等功能引用。
  - `router`，路由入口。
  - `stores`，状态管理入口，当前版本中我们使用Pinia。
  - `utils`，全局工具方法存放目录。我们并不建议使用全局工具，因为那样将导致某些模块不能独立开发，而必须要依赖于拥有此工具的工程，但在某些特殊场景下提取公用工具是必要的，所以我们保留了此能力。

### 可以做的事情

当脚手架工程成功运行后，我们已经可以开始实际的开发工作，我们可以做这些事情：

 - 在`public`目录中添加全局静态资源。
 - 根据需要修改`config`目录中相应环境的配置信息。
 - 在`modules`目录中添加新的功能模块。
 - 在`css`目录中修改全局样式。
 - 在`utils`目录中添加全局工具。

 但这些工作在通常的开发过程中不一定需要全都做，当我们考虑不同开发人员角色的时候，可以做如下拆分：

#### 模块开发人员

模块开发人员通常只需要：

 - 在`modules`目录中添加新的功能模块。

#### 系统集成人员

系统集成人员通常需要：

 - 根据需要修改`config`目录中相应环境的配置信息。
 - 在`modules`目录中引入需要的功能模块。


我们将分别做详细的介绍。


## 模块开发

### 修改启动模块

前面提到过，模块开发人员可能需要禁用内置模块来得到一个“干净”的环境来创建自己的模块。要禁用内置模块，或修改需要启动的模块，可以通过修改`src/config/config.development.js`来实现，如下：

```javascript
export default {
  modules: [
    // 'main'
  ],
};

```

这里的`modules`就是需要启动的模块列表，脚手架默认启动`main`模块，他是一个示意性的“封装模块”，用来更精细地控制所启动的其他模块。关于“封装模块”后面会有详细介绍，这里我们只需要把它从`modules`列表中移除即可将其禁用。


### 创建模块

接下来我们创建一个新模块，在`modules`目录中添加一个子目录`my-first-module`，其目录结构如下：

```
-- src
  -- modules
    -- my-first-module
      -- index.js
```

其中`index.js`是我们新模块的入口文件，它的内容如下：

```
import { defineComponent, h } from 'vue';

export default {
  routers: [
    {
      path: '/',
      component: defineComponent({
        name: 'MyComp',
        setup() {
          return ()  => h('div', {
            class: 'absolute-center text-h3'
          }, ['hello world']);
        },
      }),
    },
  ],
};
```

这时我们就已经有了一个新的模块，而要让它被启动，我还需要将它添加到`config.development.js`的`modules`中。

```
export default {
  modules: [
    'my-first-module'
  ],
};

```

此时再回到浏览器中访问`http://localhost:8080`(或根据终端提示访问相应的端口)，你将看到`hello world`的文字，也就是我们模块中的第一个页面。

这里，我将页面、路由、模块入口都写在了同一个文件当中，这可以运行，但从通常的最佳实践来说，我们应该把他们拆分开来。FreeEIS对于如何在模块内部拆分组织代码没有强制性规范，你可以根据自己的习惯来进行开发，只要在模块入口文件中指明需要暴露的路由即可。

如下是我们进行拆分后的多个文件结构，其结果和我们上述单个文件的效果完全一致。

```
-- src
  -- modules
    -- my-first-module
      -- index.js           # 这里依然是我们的模块入口文件
      -- view               # 我们把“视图”文件放在这个目录中
        -- hellowWorld.vue  # 这是我们的hello world页面
      -- routes             # 我们把定义路由的部分放在这个目录中
        -- index.js         # 这里面定义我们的路由
```

其中：

```
# my-firrst-module/index.js

import routers from './routers';

export default {
  routers,
};
```


```
# my-firrst-module/view/helloWorld.vue

<template>
  <div class="absolute-center text-h3">hello world</div>
</template>

<script>
import { defineComponent } from 'vue';

export default defineComponent({
  name: 'HelloWorldPage',
})
</script>

```


```
# my-first-module/routers/index.js

export default [
  {
    path: '/',
    component: () => import('../view/helloWorld.vue'),
  }
];

```

上面的拆分是示意性的，在复杂的模块中，需要根据实际情况来定，但核心思路是，FreeEIS不限制你的代码组织方式，只要确保在模块入口文件中可以找到相应的路由即可。


### 模块配置

组件或页面有`props`可以使我们的使用者对某些内容或逻辑加以控制，模块也同样需要这样的机制。

在我们的这个实例模块中，假设我们需要hello的目标不是固定的'world'， 而是需要根据情况而定，那么我们可以在模块中添加相应的配置参数，使得这部分内容可变。

我们在模块入口文件添加如下配置定义（但同样，这种定义可以被剥离出来放在任何其他文件中）：

```
# my-firrst-module/index.js

import routers from './routers';

export default {
  config: {
    greetingTo: 'world',
  },
  routers,
};
```

我们在组件代码中如下可以引用这个配置参数：

```
# my-firrst-module/view/helloWorld.vue

<template>
  <div class="absolute-center text-h3">hello {{greetingTo}}</div>
</template>

<script>
import { defineComponent, ref, getCurrentInstance, watchEffect } from 'vue';

export default defineComponent({
  name: 'HelloWorldPage',
  setup() {
    const { proxy: { ctx } } = getCurrentInstance();
    const greetingTo = ref('');

    watchEffect(() => {
      greetingTo.value = ctx.config['my-first-module'].greetingTo;
    })

    return {
      greetingTo,
    };
  },
})
</script>

```

如果不使用组合式API，你可以通过`this.ctx`访问全局上下文，这个全局上下文中包括如下两个重要的内容：

 - `ctx.config`, 当前生效的全局配置信息，包括从`config`目录中根据当前环境加载的配置信息，也包括每个模块的配置信息，比如上面我们配置的`greetingTo`就可以通过`ctx.config['my-first-module'].greetingTo`来访问。
 - `ctx.modules`, 一个维护所有被加载的模块的列表，也就是你可以访问所有被加载的模块，这给使用或扩展现有模块带来了可能。

### 模块使用者覆盖模块配置项

假设我们的`my-first-module`已经开发完成，系统集成者或其他希望使用此模块的开发者，可能需要对我们定义的`greetingTo`配置项进行更多的控制，他可以这样做：

```
# src/config/config.development.js

export default {
  modules: [
    'my-first-module',
  ],

  'my-first-module': {
    greetingTo: '中国'
  },
};

```

这时，回到浏览器，我们可以看到，页面上已经显示`hello 中国`了。

### 接口请求

上面我们演示子如何创建新模块，并在模块中定义可变的配置项，但另一个常见情况是前端的某些数据来自后端接口。

我们继续假设，在我们这个新模块中，greetingTo的内容来自一个叫`myModule/doSomething`的`POST`接口，我们修改我们的helloWorld组件如下：

```
# my-first-module/view/helloWorld.vue

<template>
  <div class="absolute-center text-h3">hello {{greetingTo}}</div>
</template>

<script>
import { defineComponent, ref, getCurrentInstance } from 'vue';

export default defineComponent({
  name: 'HelloWorldPage',
  setup() {
    const { proxy:vm } = getCurrentInstance();
    const greetingTo = ref('');

    vm.postRequest('/myModule/doSomething').then((d) => {
      greetingTo.value = d?.greeting || '中国';
    })

    return {
      greetingTo,
    };
  },
})
</script>
```

此时页面会报错，因为此接口不存在。这就需要用到mock功能。我们在我们的模块入口文件中添加mock代码如下：

```
import routers from './routers';

export default {
  config: {
    greetingTo: 'world',
  },
  routers,
  mock: (Mock) => {
    Mock.mock('/myModule/doSomething', 'post', {
      greeting: 'FreeEIS'
    })
  },
};

```

这时再回到浏览器，可以看到页面上显示的是`hello FreeEIS`，这种情况下前端可以完全独立开发，而不需要后端的支持，当然，对于接口的定义双方要有一致的规范。如果一切正常，当后端接口开发完成后我们的页面即可以自然地过度到前后端的连接。

### 接口请求方法

上面我们看到，通过`vm.postRequest`我们调用了一个`post`类型的接口，其实在`vm`(也就是非组合式API情况下的`this`)中，我们有如下方法：

 - getRequest
 - postRequest
 - putRequest
 - deleteRequest

他们分别调用相应方法的接口，都可以传入参数对象，但`get`调用时的参数对象会被解析成路径中的`query`字符串，而其他调用方法中的参数对象会以`body`的形式发送。比如：

```
const url = '/myModule/doSomething';

vm.getRequest(url, { name: 'free' });
# get /myModule/doSomething?name=free

vm.postRequest(url, { name: 'free' })
# post /myModule/doSomething ，body为： { name: 'free' }

vm.putRequest(url, { name: 'free' });
# put /myModule/doSomething ，body为： { name: 'free' }

vm.deleteRequest(url, { name: 'free' });
# delete /myModule/doSomething ，body为： { name: 'free' }
```

### 多语言支持

FreeEIS中使用`vue-i18n`来提供多语言支持，但我们对其进行了封装，使得多语言支持更加简单。

继续使用上面我们创建的模块，假设我们需要对`hello`这个词进行中文和英文的支持，我们需要创建一个18n目录，并在其中创建如下结构的文件：

```
-- src
  -- modules
    -- my-first-module
      -- i18n
        -- zh-cn
          - index.js  # 中文翻译字典入口文件
        -- en-us
          - index.js  #  英文翻译字典入口文件
```

其中：

```
# i18n/zh-cn/index.js

export default {
  hello: '你好'
}
```


```
# i18n/en-us/index.js

export default {
  hello: 'hi'
}
```

然后在`helloWorld.vue`中进行实时翻译：


```
# my-first-module/view/helloWorld.vue

<template>
  <div class="absolute-center text-h3">{{$t('hello')}} {{greetingTo}}</div>
</template>

<script>
import { defineComponent, ref, getCurrentInstance } from 'vue';

export default defineComponent({
  name: 'HelloWorldPage',
  setup() {
    const { proxy:vm } = getCurrentInstance();
    const greetingTo = ref('');

    vm.postRequest('/myModule/doSomething').then((d) => {
      greetingTo.value = d?.greeting || '中国';
    })

    return {
      greetingTo,
    };
  },
})
</script>
```

此时，回到浏览器，看到的将是`你好 FreeEIS`。因为FreeEIS在不能判断当前需要使用的语言时默认使用中文。

如下代码，我们添加了两个按钮，来切换当前语言：


```
# my-first-module/view/helloWorld.vue

<template>
  <div class="absolute-center text-h3">
    {{$t('hello')}} {{greetingTo}}

    <div class="row justify-center q-gutter-md q-mt-lg">
      <q-btn label="中文" @click="changeLocaleTo('zh-cn')"></q-btn>
      <q-btn  label="English" @click="changeLocaleTo('en-us')"></q-btn>
    </div>
  </div>
</template>

<script>
import { defineComponent, ref, getCurrentInstance } from 'vue';

export default defineComponent({
  name: 'HelloWorldPage',
  setup() {
    const { proxy:vm } = getCurrentInstance();
    const greetingTo = ref('');

    vm.postRequest('/myModule/doSomething').then((d) => {
      greetingTo.value = d?.greeting || '中国';
    })

    return {
      greetingTo,
      changeLocaleTo: (l) => {
        vm.$i18n.locale = l;
      }
    };
  },
})
</script>

```

这时回到浏览器，可以通过两个按钮来切换语言。

内置的`free-fe-core-modules`模块中有一些基础组件，比如`SelectLocales`组件，可以用来切换语言。我们通过添加此模块到配置中，来启动他：


```
# config/config.development.js

export default {
  modules: [
    'core-modules',
    'my-first-module',
  ],

  'my-first-module': {
    greetingTo: '中国'
  },
};

```


再添加`SelectLocales`组件到`helloWorld`页面中，如下：

```
<template>
  <div class="absolute-center text-h3">
    {{$t('hello')}} {{greetingTo}}

    <div class="row justify-center q-gutter-md q-mt-lg">
      <select-locales></select-locales>
    </div>
  </div>
</template>
```

这时回到浏览器，可以看到修改的效果。`SelectLocales`组件默认显示一个图标，当点击时出现下来菜单来选择语言，此组件更适合放在像顶部菜单栏之类的位置。

当我们有更多的语言需要支持时，只要在i18n目录中添加相应的翻译字典，即可自动添加到下拉菜单中，实现实时翻译。比如，我们添加另一种语言，如下：


```
-- src
  -- modules
    -- my-first-module
      -- i18n
        -- zh-cn
          - index.js  # 中文翻译字典入口文件
        -- en-us
          - index.js  # 英文翻译字典入口文件
        -- 火星语
          - index.js  # 火星语翻译字典入口文件
```


```
# i18n/火星语/index.js

export default {
  hello: '🚀🚀🚀'
}

```

此时回到浏览器中，点击切换语言按钮，可以看到`火星语`选项，选择`火星语`后页面内容变为`🚀🚀🚀 FreeEIS`。

但，因为火星人不认识中文`火星语`这三个字，所以，虽然我们地球人对火星语的定义为`火星语`，就像我们定义中文为`zh-cn`一样，那么我们需要在页面上的下拉菜单中显示火星语的`火星语`三个字的意思，此时我们需要在全局配置菜单中的`locales`中添加此项语言，比如下：

```
# config/config.default.js

....
locales: [
  ....,
  {
    name: '🚀🚀🚀',
    locale: '火星语',
  },
],
....

```

此时回到浏览器中，可以看到多语言选择的下拉框中自动出现了`🚀🚀🚀`的选项，这是火星人可以看懂的文字。

注意，这些配置都可以根据运行环境不同而不同，运行环境中配置的相同项将会覆盖`config.default.js`中的项。


## 系统集成

系统集成开发者与模块开发者的目标不同，他们需要按需求把各功能模块集成到一起，使他们可以一起工作。

功能模块有三种方式引入：

 - 公开发布的模块可以通过`yarn add`添加到package.json中。
 - 私有模块可以直接将模块放在`modules`目录中。
 - 远程开发人员开发的放在独立代码库中的模块可以通过`git submodule`添加到`modules`目录中。

比如，我们添加了三个模块：

 - free-fe-core-modules，已经公开发布的模块。
 - my-first-module，我们自己开发的直接入在modules目录中的模块。
 - my-second-module，另一名开发人员开发的放在独立代码仓库中的模块。

引入这三个模块后，我们的集成工程的目录结构如下：

```
-- `app`
  -- `node_modules`
    -- `free-fe-core-modules`，通过`yarn add free-fe-core-modules`添加。（脚手架中已经添加）
  -- `src`
    -- `modules`
      -- `my-first-module`，这是一个本地目录，模块代码就在这里。
      -- `my-second-module`，这是通过`git submodule`添加的远程库。
```

### 启用需要的模块

引入的模块默认不会被加载运行，如果需要加载运行他们，需要将他们添加到config的modules中，上面提到的三种方式添加的模块都是以同样的方式启动。像这样：

```
# config/config.development.js

export default {
  modules: [
    'core-modules',
    'my-first-module',
    'my-second-module',
  ],

  'my-first-module': {
    greetingTo: '中国'
  },
};

```

这里你可能会注意到，我们添加了一个名为`core-modules`的模块，是因为名字以`free-fe-`开头的模块在引入时，可以省略这个前缀。但是我们不建议你使用这样的命名方法，因为他们是为内置模块预留的。


### 封装模块

前面我们提到了封装模块，他是一种特殊的模块。说他特殊是指他除了拥有普通模块的所有功能和特性外，还会使用一种特殊功能`路由引用`来重新编排所有需要暴露出来的路由。我们举例来说明具体的使用方法。

我们将`my-first-module`复制一份，并修改名字为`my-second-module`，并将`my-second-module`中的`helloWorld`页面中的内容改为：

```
# modules/my-second-module/view/helloWorld.vue

<template>
  <div class="absolute-center text-h3">
    hello from second module
  </div>
</template>

<script>
import { defineComponent } from 'vue';

export default defineComponent({
  name: 'SecondHelloWorldPage',
})
</script>

```

并将`my-second-module`里的`routers`中路由路径改为`/second`：


```
# modules/my-second-module/routers/index.js

export default [
  {
    path: '/second',
    component: () => import('../view/helloWorld.vue'),
  }
];

```

这时，我们通过浏览器可以分别访问`http://localhost:8080`和`http://localhost:8080/#/second`要以分别看到`my-first-module`和`my-second-module`中的两个页面。

但是，我们很可能不希望两个页面的路由路径是这样的，而是需要遵从我们一套更复杂系统的整体规划。比如，我们需要使用`/hello/first`和`/hello/second`两个路径来访问这两个页面。我们新建一个模块，叫`wrapper`，目录结构如下：

```
--- app
  -- src
    -- modules
      -- wrapper
        -- index.js
```

其中：

```
# modules/wrapper/index.js

export default {
  config: {
    dependencies: [
      'core-modules',
      'my-first-module',
      'my-second-module',
    ],
  },
  routers: [
    {
      ref: 'my-first-module>firstHello',
      path: '/hello/first',
    },
    {
      ref: 'my-second-module>secondHello',
      path: '/hello/second',
    },
  ],
}

```

这里我们通过`wrapper`中的`routers`定义，应用了其他模块的路由，方法是使用形如`ref: [模块名称]>[路由名称]`的定义，引用路由后相当于将被引用模块的相应路由配置复制到了这里，但我们可以通过重新定义像`path`这样的属性来覆盖被引用模块中的值。

注意这里，我们添加了`dependencies`列表，让FreeEIS知道，这个`wrapper`模块依赖于此三个模块，以使他们可以在`wrapper`模块前被加载。

此时会到浏览器，将会看到报错，因为根据路由名称从两个被引用模块中找不到`firstHello`和`secondHello`路由。我们回到两个被引用模块的路由定义中，将其修改为如下形式，添加`name`定义:

```
# modules/my-first-module/routers/index.js

export default [
  {
    path: '/',
    name: 'firstHello',
    component: () => import('../view/helloWorld.vue'),
  }
];

```

```
# modules/my-second-module/routers/index.js

export default [
  {
    path: '/second',
    name: 'secondHello',
    component: () => import('../view/helloWorld.vue'),
  }
];

```

并且，修改`config.development.js`中启用的模块，如下：

```
# config/config.development.js

export default {
  modules: [
    'wrapper',
  ],

  'my-first-module': {
    greetingTo: '中国'
  },
};

```

这里我们告诉FreeEIS只加载`wrapper`一个模块，因为我们希望系统并不是直接加载引入进来的所有模块，而是更可控地对他们进行选择性地加载。这样做的好处是，当我们有些模块中的某些路由不需要暴露的时候，我们可以不在`wrapper`的路由定义中引用，而我们告诉FreeEIS只加载`wrapper`模块，这样系统就会只根据`wrapper`中的配置进行加载。

比如，我们在`my-second-module`中添加一个新的页面：


```
# modules/my-second-module/routers/index.js

export default [
  {
    path: '/second',
    name: 'secondHello',
    component: () => import('../view/helloWorld.vue'),
  },
  {
    path: '/third',
    name: 'thirdHello',
    component: () => import('../view/helloWorld.vue'),
  },
];

```

如果我们直接将`my-second-module`加入到`config.development.js`中的`modules`列表中，则我们可以通过访问`/third`来访问新定义的页面，但我们只添加`wrapper`到`config.development.js`中`modules`中后，我们不能访问这个页面，因为他不在`wrapper`的路由定义中。

另外，需要注意的是，我们为了引用其他模块的路由，需要在被引用路由中添加`name`属性，以区分不同路由定义，这应该成为一种默认的良好习惯，因为模块开发人员所开发的模块就是要给系统集成人员或其他开发人员使用的。


### 配置
### 运行



高阶：


模块入口
路由
路由参数
页面
组件


filters
validators
其他


模块内所有可能的内容，模块扩展，hook

内置模块介绍
